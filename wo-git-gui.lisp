;;;; wo-git-gui.lisp

(in-package #:wo-git-gui)

;;; "wo-git-gui" goes here. Hacks and glory await!

(defparameter *dot-cmd*
  #+linux "/usr/bin/dot"
  #+darwin "/usr/local/bin/dot"
  #+win32 "d:/Programs/graphviz/bin/dot.exe")

(defparameter *git-project*
  #P"/Users/woudshoo/Development/Source/lisp-devel-systems/wo-git-gui/.git")

(defparameter *webserver-acceptor* nil)
(defparameter *default-graph* nil)

(defparameter *dead-revisions* nil)

(defparameter *version-names-scanner*
  (cl-ppcre:create-scanner "v[0-9]+\\.[0-9]+\\.[0-9]\\.[0-9]+"))

(defparameter *default-reducers*
  (list
   (wo-graph-functions:make-single-sided-reducer
    #'wo-graph:sources-of-vertex
    #'wo-graph:targets-of-vertex
    0 nil)
   (wo-graph-functions:make-single-sided-reducer
    #'wo-graph:targets-of-vertex
    #'wo-graph:sources-of-vertex
    0 nil)
   (wo-graph-functions:make-single-sided-reducer
    #'wo-graph:targets-of-vertex
    #'wo-graph:sources-of-vertex
    1 (lambda (sr tg g) (wo-graph:add-edge sr tg
					   (make-array 3 :initial-contents (list 'reduced
										 sr
										 tg))
					   g)))
   (wo-graph-functions:make-single-sided-reducer
    #'wo-graph:sources-of-vertex
    #'wo-graph:targets-of-vertex
    1 (lambda (tg sr g) (wo-graph:add-edge sr tg
					   (make-array 3 :initial-contents (list 'reduced
										 sr
										 tg))
					   g)))))


(setf (logical-pathname-translations "tmp")
      '(("**;*.*.*" "/tmp/")))


(defun make-tmp-name (base-name type)
  "Creates a tmp file with name taken from base-name and the type from `type'.
Its main use is to create a set of related files based upon a given name, e.g.
name.dot name.png name.svg, ..."
  (merge-pathnames (make-pathname :host "tmp" :type type) base-name))

(defun tmp-name-exists (base-name type)
  "I added here translate-logical-pathname because
this function fails with a complaint about a _ when
sbcl is started in a directory containing a _"
  (directory (translate-logical-pathname (make-tmp-name base-name type))))

(defun pathname-to-string (pathname)
  "Converts a CL pathname to a string representation that
can be used an argument to an external process."
  (format nil "~A" (translate-logical-pathname pathname)))

(defun clear-cache ()
  "Remove all cache files that are generated by wo-git-gui.
Note that it just removes all files matching '.dot' and '.svg'
from the logical path tmp, so be carefull."
  (mapc #'delete-file (directory #P"tmp:*.dot"))
  (mapc #'delete-file (directory #P"tmp:*.svg")))

(defun read-graph (&optional (git-project *git-project*))
  (setf *default-graph* (wo-git:get-git-graph git-project)))

(defun reset ()
  (wo-git:run-git *git-project* "fetch")
  (clear-cache)
  (read-graph))

(defun run-dot (dot-file image-file &optional &key cmap-file (node-href "\\N"))
  "Run dot on the `dot-file' and the resulting image will be written
to `image-file'.  If the optional `cmap-file' is given, the cmapx file is written to
that file.

The dot commad is taken from the *dot-cmd* variable and the command line for dot is

 dot <dot-file>  -Nhref=\\N r-T <type of image-file> -o <image-file>

or

 dot <dot-file> -Nhref=\\N -T <type of image-file> -o <image-file> -Tcmapx -o <cmap-file>
"
  (sb-ext:run-program *dot-cmd*
	       #-sbcl :arguments (if cmap-file
				     (list
				      (pathname-to-string dot-file)
				      (format nil "-Nhref=~A" node-href)
				      "-T"
				      (string-downcase (pathname-type image-file))
				      "-o"
				      (pathname-to-string image-file)
				      "-Tcmapx" "-o"
				      (pathname-to-string cmap-file))
				     (list
				      (pathname-to-string dot-file)
				      (format nil "-Nhref=~A" node-href)
				      "-T"
				      (string-downcase (pathname-type image-file))
				      "-o"
				      (pathname-to-string image-file)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Want to change it to weblocks.  If that is able to include svg's at least.
;;;
(pushnew (hunchentoot:create-folder-dispatcher-and-handler
	  "/include-files/"
	  (merge-pathnames (make-pathname :directory '(:relative "include-files"))
			   (asdf:system-source-directory :wo-git-gui)))
	 hunchentoot:*dispatch-table*)

(defun start-server (&optional &key (port 8988))
  "Start git gui webserver at port 8988 on this host."
  (unless *webserver-acceptor*
    (setf *webserver-acceptor* (make-instance 'hunchentoot:acceptor :port port)))
  (hunchentoot:start *webserver-acceptor*))

(defun stop-server ()
  "Stops the git gui webserver"
  (hunchentoot:stop *webserver-acceptor*))

(defun turn-on-debugging ()
  (setf hunchentoot:*show-lisp-errors-p* t)
  (setf hunchentoot:*show-lisp-backtraces-p* t))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun subgraph (vertex-set graph)
  (wo-graph-functions:simplify graph :selector (lambda (v g)
			      (declare (ignore g))
			      (member v vertex-set :test #'equalp))
	    :reducers (list (wo-graph-functions:make-subgraph-reducer))))



(defun make-default-edge-attributes (selector-p)
  "Returns a edge attribute function which will color
the edge gray if one of the nodes is not interesting."
  (lambda (e g)
    (if (and (funcall selector-p (wo-graph:source-vertex e g) g)
	     (funcall selector-p (wo-graph:target-vertex e g) g))
	'(:color "black")
	'(:color "gray"))))

(defun make-color-edge-attributes ()
  "Returns a edge attribute function which will color
the edge gray if one of the nodes is not interesting."
  (lambda (e g)
    (declare (ignore g))
    (list :color
	  (if (= 3 (length e))
	      "gray"
	      "black"))))

(defun make-default-node-attribute (&optional &key (color))
  "Returns a node attribute function which will show either
a dot if the vertex does not have any names or a box
with all names if the vertex does have names.

If a color function is supplied it will be used to add a color attribute with
the result of the `color' function called on the vertex."
  (lambda (v g)
    (concatenate 'list
		 (alexandria:if-let ((names (wo-git:vertex-names v g)))
		   `(:shape :box :label ,(format nil "\"~{~A~^\\n~}\"" names))
		   (list :shape :point))
		 (when color
		   `(:color ,(funcall color v))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Utility function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun name-or-rev-to-vertex (name graph)
  "Basically a wrapper around the function with the same name in the wo-git package.
But this one will return a valid vertex even if the name is empty."
  (let ((candidate (wo-git:name-or-rev-to-vertex name graph)))
    (if (member candidate (wo-graph:all-vertices graph) :test #'equal)
	candidate
	(first (wo-graph:all-vertices graph)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun to-be-merged-graph (mark-a mark-b graph stream)
  (let* ((outgoing-a (wo-graph-functions:neighborhood mark-a graph :selector #'wo-graph:targets-of-vertex))
	 (incoming-b (wo-graph-functions:neighborhood mark-b graph :selector #'wo-graph:sources-of-vertex)))

    (labels ((selector (v g)
	       (or (equalp mark-a v)
		   (and (wo-git:vertex-names v g)
			(and (member v outgoing-a :test #'equalp))
			(not (member v incoming-b :test #'equalp)))))

	     (color (v)
	       (cond
		 ((equalp v mark-a) "blue")
		 ((equalp v mark-b) "green")
		 ((not ( member v incoming-b :test #'equalp)) "black")
		 (t "gray"))))

      (let ((result (wo-graph-functions:simplify graph :selector #'selector
						 :reducers *default-reducers*)))
	(write-to-dot stream result
		      :graph-attributes '(:rankdir "LR")
		      :node-attributes (make-default-node-attribute :color #'color)
		      :edge-attributes (make-default-edge-attributes #'selector))
	result))))


(defun neighborhood-graph (vertex graph distance stream &optional &key
			   mark-a mark-b (reducers *default-reducers*))
  "Write the neighborhood graph as a dot file to `stream'
and returns the reduced graph.

The neighboorhood is taken of `vertex' with the given `distance'.
It will also make sure that `mark-a' and `mark-b' are not removed from
the graph if they are specified.

Finally the optinal argument `reducers' is a list of reducers which is applied
to the graph.  This list of reducers is what makes the graph smaller."
  (let* ((neighbor-vertices
	  (wo-util:add-non-nil
	   (wo-graph-functions:neighborhood vertex graph :max-distance distance)
	   (list mark-a mark-b)))
	 (extended-neighbor-vertices
	  (wo-util:add-non-nil
	   (wo-graph-functions:neighborhood vertex graph :max-distance (+ 1 distance))
	   (list mark-a mark-b))))

    (labels ((selector (v g)
	       (declare (ignore g))
	       (member v extended-neighbor-vertices :test #'equalp))

	     (color (v)
	       (cond
		 ((equalp v vertex) "red")
		 ((equalp v mark-a) "blue")
		 ((equalp v mark-b) "green")
		 ((member v neighbor-vertices :test #'equalp) "black")
		 (t "gray"))))

      (let ((result (wo-graph-functions:simplify graph :selector #'selector
						 :reducers reducers)))
	(write-to-dot stream result
		      :node-attributes (make-default-node-attribute :color #'color)
		      :edge-attributes (make-color-edge-attributes))
	result))))


(defun simple-name-attribute (vertex graph)
  (let ((names (wo-git:vertex-names vertex graph)))
    (if names
	(list :shape "box" :label (format nil "\"~{~A~^\\n~}\"" names))
	(list :shape "point"))))

(defun write-to-dot (stream graph &optional &key
		     (graph-attributes nil)
		     (node-attributes (constantly nil))
		     (edge-attributes (constantly nil)))
  "Writes the `graph' as a dot digraph graph to `stream'.
The formatting of the nodes and edges is optionally modified
by the functions `node-attributes' and `edge-attributes'.

The optional argument `graph-attributes' is a property list and
is written at the beginning of the graph.

If function `node-attributes' is a function taking two arguments,
a vertex and the graph.   It should return a property list with
such as (:shape :box :label \"text\") and these will be incorperated
into the dot file as ... [shape=box,label=\"text\"].

The same holds for `edge-attributes', however this is a function of 2 arguments
the edge and graph.  But the result should again be a property
list which will be formatted the same as for the `node-attributes'."
  (let ((*print-right-margin* 10000)
	(*print-case* :downcase))
    (format stream "digraph {~%~@[~{~A=~A;~^~%~}~]~%" graph-attributes)
    (loop :for node :in (wo-graph:all-vertices graph)
       :for attributes = (funcall node-attributes node graph)
       :do
       (format stream "\"~A\"~@[ [~{~A=~A~^,~}]~];~%" node attributes))
    (loop :for node :in (wo-graph:all-vertices graph)
       :do
       (loop :for edge :in (wo-graph:outgoing-edges node graph)
	  :for target = (car (wo-graph:target-vertex edge graph))
	  :do
	  (when target
	    (format stream "\"~A\" -> \"~A\"~@[ [~{~A=~A~^,~}]~];~%"
		    node target
		    (funcall edge-attributes edge graph)))))
    (format stream "}")))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun copy-file-to-stream (file-name stream &optional &key (skip 0))
  (with-open-file (in-stream file-name :direction :input)
    (loop :for line = (read-line in-stream nil nil)
       :repeat skip
       :while line)
    (loop :for line = (read-line in-stream nil nil)
       :while line
       :do
       (write-line line stream))))

(defun html-select-git-name (var-name default-vertex names stream)
  (cl-who:with-html-output (s stream)
    ((:select :name var-name)
     (loop :for name :in (sort (copy-seq names) #'string<)
	:for vertex = (wo-git:name-to-vertex name *default-graph*)
	:finally (when default-vertex
		   (cl-who:htm ((:option :value default-vertex :selected "true")
				 (cl-who:str default-vertex))))
	:do
	(if (string-equal name default-vertex)
	    (progn (cl-who:htm
		    ((:option :value name :selected "true") (cl-who:str name)))
		   (setf default-vertex nil))
	    (cl-who:htm
	     ((:option :value name) (cl-who:str name))))))))

(defun create-svg-graph (base-name graph-to-dot-writer &optional node-ref-string)
  "Creates dot file if needed and runs dot if needed."
    (unless (tmp-name-exists base-name "dot")
      (with-open-file (s (make-tmp-name base-name "dot") :direction :output :if-exists :supersede)
	(funcall graph-to-dot-writer s)))
    (unless (tmp-name-exists base-name "svg")
      (run-dot (make-tmp-name base-name "dot")
	       (make-tmp-name base-name "svg")
	       :node-href node-ref-string )))

(defun write-info-selected-revision (vertex stream)

  (cl-git:with-git-repository (*git-project*)
    (let* ((commit (cl-git:git-commit-lookup  vertex))
	   (author (cl-git:git-commit-author commit)))
      (cl-who:with-html-output (s stream)
	(:table
	 (:tr (:td "Message")
	      (:td (cl-who:str (cl-git:git-commit-message commit))))
	 (:tr (:td "Author")
	      (:td (cl-who:str (getf author :name))))
	 (:tr (:td "Time")
	      (:td (cl-who:str (getf author :time)))))
	(cl-git:git-commit-close commit)))))


(define-easy-handler (neighborhood :uri "/neighborhood-graph")
    (vertex distance mark-a mark-b)
  "Shows the default neighborhood graph with a default distance.

Need to figure out how to embed this into a complete page with selection
possibilities etc.   Might just be embedded by using different means in html, but
not so sure yet."

  (let* ((*print-pretty* nil)
	 (distance (or (and distance (parse-integer distance)) 2))
	 (distance-str (format nil "~D" distance))
	 (vertex-vertex (name-or-rev-to-vertex vertex *default-graph*))
	 (vertex-a (name-or-rev-to-vertex mark-a *default-graph*))
	 (vertex-b (name-or-rev-to-vertex mark-b *default-graph*))
	 (base-name (format nil "nbh-~D-~A-~A-~A"
			    distance vertex-vertex vertex-a vertex-b)))

    (create-svg-graph base-name
		      (lambda (s)
			(neighborhood-graph vertex-vertex *default-graph*
					    distance s
					    :mark-a vertex-a :mark-b vertex-b))
		      (format nil "neighborhood-graph?vertex=\\N&distance=~D&mark-a=~A&mark-b=~A"
			      distance (url-encode (or mark-a vertex-a))
			      (url-encode (or mark-b vertex-b))))

    (setf (hunchentoot:content-type*) "application/xml")

    (cl-who:with-html-output-to-string (ss nil :prologue nil)
      ((:html
	 :xmlns "http://www.w3.org/1999/xhtml"
	 "xmlns:svg" "http://www.w3.org/2000/svg"
	 "xmlns:xlink" "http://www.w3.org/1999/xlink")
       (:head
	(:title "Neighborhood")
	(:link :rel "stylesheet" :href "/include-files/default.css"))
       (:body
	(:h1 "NEIGHBORHOOD")
	(:table
	 (:tr
	  ((:td :valign "top")
	   ((:form :action "neighborhood-graph" :method "get")
	    (:table
	     (:tr (:td "Starting revision (blue)")
		  (:td (html-select-git-name "mark-a" (or mark-a vertex-a) (wo-git:all-names *default-graph*) ss)))
	     (:tr (:td "End revision (green)")
		  (:td (html-select-git-name "mark-b" (or  mark-b vertex-b) (wo-git:all-names *default-graph*) ss)))
	     (:tr (:td "Selected revision (red)")
		  (:td (html-select-git-name "vertex" (or vertex vertex-vertex) (wo-git:all-names *default-graph*) ss)))
	     (:tr (:td "Distance")
		  (:td ((:input :type "text" :name "distance" :value distance-str)))))
	    ((:input :type "submit" :value "Regenerate")))
	   (:h2 "Other graphs")
	   ;; still to change vertex-a and vertex-b back to mark-a and mark-b
	   (:a :href (format nil "unmerged?mark-a=~A&amp;mark-b=~A"
			     (url-encode (or mark-a vertex-a))
			     (url-encode (or mark-b vertex-b))) "UNMERGED")
	   (:h2 "Versions")
	   (:table
	    (:tr (:th "Next Versions") (:th "Previous Versions"))
	    (:tr
	     (:td
	      (:table
	       (:tr
		(loop :for name-list :in (version-or-after vertex-vertex)
		   :do
		   (cl-who:htm
		    (:td
		     (:table
		      (loop :for name :in name-list :do
			 (cl-who:htm
			  (:tr (:td (cl-who:str name))))))))))))
	     (:td
	      (:table
	       (:tr
		(loop :for name-list :in (version-or-before vertex-vertex)
		   :do
		   (cl-who:htm
		    (:td
		     (:table
		      (loop :for name :in name-list :do
			 (cl-who:htm
			  (:tr (:td (cl-who:str name))))))))))))))
	   (:h2 "Selected Revision")
	   (write-info-selected-revision vertex-vertex ss))
	  ((:td :valign "top")
	   (copy-file-to-stream (make-tmp-name base-name "svg") ss :skip 4)))))))))

(define-easy-handler (non-merged :uri "/unmerged")
    (mark-a mark-b)
  (let* ((*print-pretty* nil)
	 (vertex-a (name-or-rev-to-vertex mark-a *default-graph*))
	 (vertex-b (name-or-rev-to-vertex mark-b *default-graph*))
	 (base-name (format nil "tbm-~A-~A" vertex-a vertex-b))

	 (unmerged-revisions
	  (wo-util:remove-from-set
	   (wo-graph-functions::reachable-from-not-reachable-from
	    vertex-a #'wo-graph:targets-of-vertex
	    vertex-b #'wo-graph:sources-of-vertex
	    *default-graph*)
	   *dead-revisions* :test #'string-equal)))

    (create-svg-graph base-name
		      (lambda (s)
			(to-be-merged-graph vertex-a vertex-b *default-graph* s)))

    (setf (hunchentoot:content-type*) "application/xml")
    (cl-who:with-html-output-to-string (s nil :prologue nil)
      ((:html
	:xmlns "http://www.w3.org/1999/xhtml"
	 "xmlns:svg" "http://www.w3.org/2000/svg"
	 "xmlns:xlink" "http://www.w3.org/1999/xlink"
	)
       (:thead
	(:title "UNmerged"))
       (:body
	(:h1 "UNMERGED")
	((:form :action "unmerged" :method "get")
	 (:table
	  (:tr (:td "Starting revision")
	       (:td (html-select-git-name "mark-a" mark-a (wo-git:all-names *default-graph*) s)))
	  (:tr (:td "End revision")
	       (:td (html-select-git-name "mark-b" mark-b (wo-git:all-names *default-graph*) s)))
	  ((:input :type "submit" :value "Regenerate"))))
	(:h2 "Other graphs")
	(:a :href (format nil "neighborhood-graph?vertex=~A&amp;mark-a=~A&amp;mark-b=~A" (url-encode mark-a) (url-encode mark-a) (url-encode mark-b)) "NEIGHBORHOOD")
	(:h2 "Table")
	(:table
	 (loop :for rev :in unmerged-revisions
	    :for names = (wo-git:vertex-names rev *default-graph*)
	    :do
	    (when names
	      (cl-who:htm
	       (:tr (:td (cl-who:str rev)) (:td (format s  "~{~A~^,~}" names)))))))
	(:h2 "Graph")
	(copy-file-to-stream (make-tmp-name base-name "svg") s :skip 4))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun version-or-after (vertex)
  "First attempt to get the version number info for commits"
  (flet ((selector (v graph)
	   (let ((names (wo-git:vertex-names v graph)))
	     (some (lambda (name)
		     (cl-ppcre:scan *version-names-scanner* name))
		   names))))

    (mapcar (lambda (v) (wo-git:vertex-names v *default-graph*))
	    (wo-graph-functions:minimal-boundary-from vertex
					      #'wo-graph:targets-of-vertex
					      #'selector
					      *default-graph*))))


(defun version-or-before (vertex)
  (flet ((selector (v graph)
	   (let ((names (wo-git:vertex-names v graph)))
	     (some (lambda (name)
		     (cl-ppcre:scan *version-names-scanner* name))
		   names))))

    (mapcar (lambda (v) (wo-git:vertex-names v *default-graph*))
	    (wo-graph-functions:minimal-boundary-from vertex
					      #'wo-graph:sources-of-vertex
					      #'selector
					      *default-graph*))))
;;; Idea
;;; What is needed is an algorithm which returns
;;;
;;; Input:  Set V of vertices in G
;;;         S a function V --> {false, true}
;;;
;;; Output:
;;;         Set W of vertices in G such that for each
;;;         w in W :
;;;             1. S(w) = true
;;;             2. All paths {v'=u1, u2, ... uk, w}, from v' in V to w
;;;                have that S(u_i) = false.
;;;
;;;
;;; One way: forward forward.
;;;
;;; Walk forward and mark with 'searching and collect all boundary elements.  When a boundary element is found, mark with 'found
;;; forward from there with 'deleting.  The 'deleting walk need to walk over all unmarked and all marked 'searching vertices.
;;; The 'searching need to walk over only unmarked elements.
;;;
;;; When done, collect all elements marked with 'found.
;;;
;;; Transition of mark:
;;;
;;;       state            from-state              S of destination              new state
;;;
;;;       unmarked          'search                      false                    'search
;;;       unmarked          'search                      true                     'found
;;;       unmarked          'found                       true/false               'delete
;;;       unmarked          'delete                      true/false               'delete
;;;       search            'search                       --                        ---
;;;       search            'delete                      true/false               'delete
;;;       found             'search                       --                        ---
;;;       found             '...
;;;
;;;
;;; Maybe simpler.
;;;
;;; Mark with integer 'n'
;;;
;;;
;;;
